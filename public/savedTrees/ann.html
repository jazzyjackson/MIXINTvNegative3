<head>
    <!--<link href="https://fonts.googleapis.com/css?family=VT323" rel="stylesheet">-->
    <link rel="stylesheet" href="/styles/style.css">
    <script src="/js/constructors/Leaf.js" defer=""></script>
    <script src="/js/constructors/Terminal.js" defer=""></script>
    <script src="/js/socket.io.js" defer=""></script>
    <script src="/js/socketevents.js" defer=""></script>
    <script src="/js/customCommands.js" defer=""></script>
    <script src="/js/utils.js" defer=""></script>
  
  <script src="//cdnjs.cloudflare.com/ajax/libs/annyang/2.5.0/annyang.min.js"></script>
    
  <script src="/js/constructors/Codemirror.js" defer="true"></script><link rel="stylesheet" href="/lib/codemirror.css"><script src="/lib/codemirror.js" defer="true"></script><script src="/lib/mode/javascript/javascript.js" defer="true"></script>
<script>
if (annyang) {
  // Let's define our first command. First the text we expect, and then the function it should call
  var commands = {
    'say *something': function(something) {
		alert(something);
    }
  };

  // Add our commands to annyang
  annyang.addCommands(commands);

  // Start listening. You can call this here, or attach this call to an event, button, etc.
  annyang.start();
}
</script><script src="/js/constructors/Tag.js" defer="true"></script><script id="repl">if (annyang) {
  // Let's define our first command. First the text we expect, and then the function it should call
  var commands = {
    'OK Computer *something': function(something) {
		console.log(something)
      	let terminal = document.getElementById('ann');
        let pprompt = terminal.getAttribute('protoprompt');
    	terminal.lastChild.textContent = pprompt + something;
    	handleInput(terminal);
    }
  };

  // Add our commands to annyang
  annyang.addCommands(commands);

  // Start listening. You can call this here, or attach this call to an event, button, etc.
  annyang.start();
}</script></head>
  <!--Giving body id body for consistency with certain functions that rely on div id-->
  <body id="body" style="position: absolute; left: 0px; top: 0px; height: 704px; width: 2000px;">

<div tabindex="1" class="leaf terminal" id="ann" history="0" protoprompt="localhost/root0 > " prompt="localhost/ann > " style="left: 805px; top: 71px; width: 400px; height: 300px; position: absolute; background: white;"><h3 class="entityHeader" style="top: 2002px;">ann<div class="removeButton">X</div></h3><p class="prompt">localhost/root0 &gt; create Codemirror</p><div class="query result" id="1480088052509">Constructor retrieved and invoked, Codemirror0 added to DOM</div><p class="prompt">localhost/root0 &gt; create Tag</p><div class="query result" id="1480088367867">Constructor retrieved and invoked, tag0 added to DOM</div><p class="prompt">localhost/root0 &gt; rename ann</p><div class="result result" id="1480088381731">root0 has been renamed to ann</div><p class="prompt">localhost/root0 &gt; save</p><div class="request" id="ann8" createdat="1480088477072">3.999 KB written successfully to ann.html at Fri Nov 25 2016 10:41:17 GMT-0500 (Eastern Standard Time)</div><p class="prompt">localhost/root0 &gt; create Tag</p><div class="query result" id="1480088530156">Constructor invoked, tag1 added to DOM</div><p class="prompt">localhost/root0 &gt; create Codemirror</p><div class="query result" id="1480088536600">Constructor invoked, Codemirror2 added to DOM</div><p class="prompt">localhost/root0 &gt; save</p><div class="request" id="ann14" createdat="1480088553261">4.412 KB written successfully to ann.html at Fri Nov 25 2016 10:42:33 GMT-0500 (Eastern Standard Time)</div><p class="prompt">localhost/root0 &gt; save</p><div class="request" id="ann16" createdat="1480088622590">4.548 KB written successfully to ann.html at Fri Nov 25 2016 10:43:42 GMT-0500 (Eastern Standard Time)</div><p class="prompt">localhost/root0 &gt; sdf</p><div class="result result" id="1480088696070">ReferenceError: sdf is not defined</div><p class="prompt">localhost/root0 &gt; !!sdf</p><div class="result result" id="1480088698036">ReferenceError: sdf is not defined</div><p class="prompt">localhost/root0 &gt; files</p><div class="result directoryContainer" id="1480088968270"><p class="fs text" title="/app.js"> app.js </p> <p class="fs text" title="/example.js"> example.js </p> <p class="fs directory" title="/node_modules"> node_modules </p> <p class="fs directory" title="/public"> public </p> <p class="fs text" title="/test.txt"> test.txt </p> <p class="fs directory" title="/testdir"> testdir </p> <p class="fs text" title="/testdirtest.txt"> testdirtest.txt </p> <p class="fs directory" title="/user"> user </p> </div><p class="prompt">localhost/root0 &gt;  ls /public</p><div class="result directoryContainer" id="1480088972841"><p class="fs directory" title="/public/images"> images </p> <p class="fs text" title="/public/index.html"> index.html </p> <p class="fs directory" title="/public/js"> js </p> <p class="fs directory" title="/public/lib"> lib </p> <p class="fs directory" title="/public/savedTrees"> savedTrees </p> <p class="fs directory" title="/public/styles"> styles </p> </div><p class="prompt">localhost/root0 &gt;  ls /public/js</p><div class="result directoryContainer" id="1480088979505"><p class="fs directory" title="/public/js/constructors"> constructors </p> <p class="fs text" title="/public/js/customCommands.js"> customCommands.js </p> <p class="fs text" title="/public/js/keyevents.js"> keyevents.js </p> <p class="fs text" title="/public/js/socketevents.js"> socketevents.js </p> <p class="fs text" title="/public/js/utils.js"> utils.js </p> </div><p class="prompt">localhost/root0 &gt;  open /public/js/customCommands.js</p><div class="result" id="1480088981535">Maybe it worked</div><p class="prompt">localhost/root0 &gt;  ls /public/js/constructors</p><div class="result directoryContainer" id="1480088995261"><p class="fs text" title="/public/js/constructors/Circle.js"> Circle.js </p> <p class="fs text" title="/public/js/constructors/Codemirror.js"> Codemirror.js </p> <p class="fs text" title="/public/js/constructors/Leaf.js"> Leaf.js </p> <p class="fs text" title="/public/js/constructors/Tag.js"> Tag.js </p> <p class="fs text" title="/public/js/constructors/Terminal.js"> Terminal.js </p> </div><p class="prompt">localhost/root0 &gt;  open /public/js/constructors/Terminal.js</p><div class="result" id="1480088997811">Maybe it worked</div><p class="prompt">localhost/root0 &gt; Codemirror4.style.width = 700</p><div class="result result" id="1480089034445">700</div><p class="prompt">localhost/root0 &gt;  open /public/js/constructors/Terminal.jssave</p><div class="result" id="1480089302091">Maybe it worked</div><p class="prompt">localhost/root0 &gt; save</p><div class="request" id="ann38" createdat="1480089308305">32.961 KB written successfully to ann.html at Fri Nov 25 2016 10:55:08 GMT-0500 (Eastern Standard Time)</div><p class="prompt">localhost/root0 &gt; save</p><div class="request" id="ann40" createdat="1480089500159">33.173 KB written successfully to ann.html at Fri Nov 25 2016 10:58:20 GMT-0500 (Eastern Standard Time)</div><p class="prompt">localhost/root0 &gt;save</p><div class="request" id="ann42" createdat="1480089612280">33.452 KB written successfully to ann.html at Fri Nov 25 2016 11:00:12 GMT-0500 (Eastern Standard Time)</div><p class="prompt">localhost/root0 &gt; save</p><div class="request" id="ann44" createdat="1480089767141">33.67 KB written successfully to ann.html at Fri Nov 25 2016 11:02:47 GMT-0500 (Eastern Standard Time)</div><p class="prompt">localhost/root0 &gt; save</p><div class="request" id="ann46" createdat="1480089782412">33.899 KB written successfully to ann.html at Fri Nov 25 2016 11:03:02 GMT-0500 (Eastern Standard Time)</div><p class="prompt">localhost/root0 &gt; 5 + 5</p><div class="result result" id="1480089839474">10</div><p class="prompt">localhost/root0 &gt; save</p><div class="request" id="ann50" createdat="1480089896809">34.213 KB written successfully to ann.html at Fri Nov 25 2016 11:04:56 GMT-0500 (Eastern Standard Time)</div><p class="prompt">localhost/root0 &gt; </p></div><div tabindex="1" class="leaf tag" id="tag0" style="left: 50px; top: 50px; width: 400px; position: absolute; background: white; min-height: 100px;"><h3 class="entityHeader">tag0<div class="editButton">A</div><div class="removeButton">X</div></h3><div id="innertag0" style="width: 100%; height: 100%;">
</div></div><div tabindex="1" class="leaf codemirrorContainer" id="Codemirror1" update="innertag0" style="left: 35px; top: 189px; width: 400px; height: 400px; position: absolute; background: white;"><h3 class="entityHeader">Codemirror1 &gt; tag0<div class="editButton">R</div><div class="removeButton">X</div></h3><textarea style="display: none;">&lt;script src="//cdnjs.cloudflare.com/ajax/libs/annyang/2.5.0/annyang.min.js"&gt;&lt;/script&gt;
</textarea></div><div tabindex="1" class="leaf codemirrorContainer" id="Codemirror2" style="left: 393px; top: 31px; width: 400px; height: 400px; position: absolute; background: white;"><h3 class="entityHeader">Codemirror2<div class="editButton">R</div><div class="removeButton">X</div></h3><textarea style="display: none;">if (annyang) {
  // Let's define our first command. First the text we expect, and then the function it should call
  var commands = {
    'OK Computer *something': function(something) {
		console.log(something)
      	let terminal = document.getElementById('ann');
        let pprompt = terminal.getAttribute('protoprompt');
    	terminal.lastChild.textContent = pprompt + something;
    	handleInput(terminal);
    }
  };

  // Add our commands to annyang
  annyang.addCommands(commands);

  // Start listening. You can call this here, or attach this call to an event, button, etc.
  annyang.start();
}</textarea></div><div tabindex="1" class="leaf codemirrorContainer" id="Codemirror3" style="left: 1217px; top: 260px; width: 400px; height: 400px; position: absolute; background: white;"><h3 class="entityHeader">Codemirror3 &gt; /public/js/customCommands.js<div class="editButton">R</div><div class="removeButton">X</div></h3><textarea style="display: none;">var customCommands = {
	whoami: whoami, 
	whatami: whatami,
	whereami: whereami, 
	howami: howami, 
	whenami: whenami,
	rename: rename,
	save: save,
	list: ls,
	files: ls,
	create: create,
	open: open,
	git: exec,
	mkdir: exec,
	ls: exec,
	touch: exec,
	pwd: exec,
	cd: exec,
	cat: exec
	

};


function exec(aTerminal, ArrArray,options){

		let requestElement = createResult('request', 'Running command on server...');
		let command = options.potentialCommand + ' ' + ArrArray.join(' ');
		fetch(`http://${window.location.host}/exec`, {
			method: 'POST',
			body: 'command=' + encodeURIComponent(command),
			headers: {
				'Content-Type': 'application/x-www-form-urlencoded'
			}
		})
		.then(res =&gt; res.json())
		.then(resObj =&gt; {
			console.log(resObj)
			requestElement.className = 'result'
			requestElement.innerText = resObj.stdout ? resObj.stdout : ( resObj.stderr ? resObj.stderr : resObj.err)
			if(resObj.stderr || resObj.err){
				requestElement.style.color = 'red';
			}
			if(requestElement.innerText === ""){
				requestElement.innerText = 'The command ran without error or output'
			}
			aTerminal.scrollTop = aTerminal.scrollHeight;
		})
		return requestElement;
}

function open(aTerminal, ArrArray){
	var requestElement = createResult('request', 'Looking for files...');
	requestElement.id = Date.now();
	let pathname = ArrArray[0];
	fetch('http://' + window.location.host + '/readFile' + '?pathname='+encodeURIComponent(pathname))
	.then(res =&gt; res.json())
	.then(resObj =&gt; {
		console.log(resObj);
		create(aTerminal, ['Codemirror',resObj,pathname])
		requestElement.className = 'result';
		requestElement.innerText = 'Maybe it worked';
		aTerminal.scrollTop = aTerminal.scrollHeight;

	})

	return requestElement;

}

function ls(aTerminal, ArrArray){
	var requestElement = createResult('request', 'Looking for files...');
	requestElement.id = Date.now();
	
	fetch('http://' + window.location.host + '/fs', {
		method: 'POST',
		body: 'pathname=' + ArrArray[0],
		headers: {
			'Content-Type': 'application/x-www-form-urlencoded'
		}
	})
	.then(res =&gt; res.json())
	.then(resObj =&gt; {
		let dirString = buildDirDisplay(resObj);
		requestElement.innerHTML = 'dirString Placeholder'; //setting the innerHTML of an empty element is sketch, apparently!
		requestElement.innerHTML = dirString;

		addDblClickListeners(requestElement);
		requestElement.className = 'result directoryContainer';
		aTerminal.scrollTop = aTerminal.scrollHeight;
	})

	return requestElement;
}

//OPEN will call create, passing the terminal, + ['CodeMirror','String of file'] as arg.
//wow how on earth did this work. create takes a terminal that its called from and an array of options? Maybe that should be an options object
function create(aTerminal, ArrArray){
	//So first up, figure out the name of the things we're creating. Here its assumed to be the first element of the ArrAray
	let newEntity = ArrArray[0];
	//create Placeholder object
	let result = createResult('query', 'Waiting for constructor to be available');
	//checks if the consturctor function is in the global scope. Constructor functions bear the same name as their source file, so 'newEntity' represents a filename and a function name.
	if(window[newEntity] === undefined){
		//if the constructor function of that name doesn't exist, create a script tag and set its src as this pathname and then append that script to the head
		let newScript = document.createElement('script');
		let pathname = '/js/constructors/' + newEntity + '.js';
		newScript.setAttribute('src', pathname);
		newScript.setAttribute('defer','true')
		document.head.appendChild(newScript);

		//loading the script is asynchronous, the constructor cannot be called immediately
		//timerID is a reference to the timer that is attempting to invoke the constructor every 10 milliseconds
		//once it succeeds in invoking the constructor, it clearsInterval of itself, so it stops trying

		let timerID = setInterval(() =&gt; {
			if(window[newEntity]){
				let newConstructor = new window[newEntity](...ArrArray.slice(1));
				let newComponent = newConstructor.render();
				document.body.appendChild(newComponent);
				clearInterval(timerID);
				result.innerText = `Constructor retrieved and invoked, ${newComponent.id} added to DOM`
			}
		}, 10)
		//after one second, the timerID is cleared whether it exists or not.
		//if the constructor still isnt available, the result inner Text is updated and a mean girls reference is printed to the console.
		//furthermore, the script tag that was generated to load the constructor src is removed from the DOM if it never worked out.

		setTimeout(()=&gt;{
			if(!window[newEntity]){
				console.log(`Stop trying to make ${newEntity} happen, it's not going to happen`)
				result.innerText = `I couldn't find a constructor for ${newEntity}`
				document.head.removeChild(newScript);
			}
			clearInterval(timerID);
		},1000)

	} else {
		//OK, the construcotr DOES exist on the global scope, so invoke it with the new keyword and pass 2nd and 3rd elements of the array to it as args
		let newConstructor = new window[newEntity](...ArrArray.slice(1)) 
		try{
			let newComponent = newConstructor.render()
			document.body.appendChild(newComponent)
			result.innerText = `Constructor invoked, ${newComponent.id} added to DOM`
		}catch(e){
			result.innerText = `${newEntity} was not undefined, but it also didn't return a DOM node from a render function, so I don't know what's up.`
		}
	}


	return result;

}

function buildDirDisplay(resObj){
	let fileObj = resObj.result;
	let pathname = resObj.pathname;
	let resultString = '';
	for(each in fileObj){
		resultString += `&lt;p class="fs ${fileObj[each]}" title="${pathname + each}"&gt; ${each} &lt;/p&gt; `
	}
	return resultString;
}


function rename(aTerminal, ArrArray){
	var newId;
	var targetElement = aTerminal;
	switch(ArrArray.length){
		case 1: newId = ArrArray[0]; break;
		case 2: newId = ArrArray[1]; targetElement = document.getElementById(ArrArray[0]); break;
		default: return createResult('error result', 'rename takes one or two arguments.');
	}
	try {
		var oldId = targetElement.id;
	} catch(e) {
		console.error(`${ArrArray[0]} doesn't appear to an element. Use an existing id.`)
		console.error(e);
		return createResult('result', `${ArrArray[0]} doesn't appear to an element. Use an existing id.`);
	}
	targetElement.id = newId;
	targetElement.firstChild.firstChild.textContent = targetElement.id;
	targetElement.setAttribute('prompt', 'localhost/' + targetElement.id + " &gt; ");
	return createResult('result', oldId + ' has been renamed to ' + targetElement.id);
}

function save(aTerminal, ArrArray, options){
	if(ArrArray.length &gt; 0){
		return createResult ('error result', 'save does not take arguments');
	}
	/* SOOOOO HACCCKYYYYY */
	saveCodeMirrorContent();
	let deadTree = document.documentElement.innerHTML; //a dead tree is a string
	let liveTree = document.createElement('html');
	liveTree.innerHTML = deadTree; //but the string is brought back into a DOM. Zombie tree, really.
	collapseCodeMirrors(liveTree); //traverse the zombie tree, modifying before saving.
	
	var requestElement = createResult('request','Attempting to send file, waiting on response');
	requestElement.setAttribute('createdAt', Date.now())
	//builds a unique id from the terminals id and the number of nodes (which should only get bigger). 
	requestElement.id = String(aTerminal.id) + aTerminal.childNodes.length;

  //OK so at this time, 'save' was just invoked as a command. The request element has not yet been handed back to the command reducer so its not on the real DOM yet.
	//So in order to get the result of this operation saved to disk, we gotta:
	//take the zombie tree before its saved, 
	//grab the terminal the terminal in the zombie tree with the same id as the live tree from which it was invokved
	//append the requestElement (via ref passed to function, it doesnt exist on the zombie tree yet)
	appendSaveTime(liveTree,aTerminal.id,requestElement)

  //save is called with an options object. When invoked with keystroke, isLocal is true, when invoked via socket message, isLocal is false or undefined.
	if(options.isLocal){
		fetch('http://' + window.location.host + '/savethis', {
			method: 'POST',
			headers: {
				"Content-Type": "application/x-www-form-urlencoded"
			},
			body: ('content=' + encodeURIComponent(liveTree.innerHTML) +
			      '&amp;fileName=' + aTerminal.id + '.html')
		})
		.then(res =&gt; res.text())
		.then(result =&gt; {
			//requestelement has an attribute recounting its creation time in ms. Subtract current time by this time to find out how longs its been since this function started.
			let starttime = requestElement.getAttribute('createdAt')
			let roundTripTime = Date.now() - starttime;
			//append that time to the string placed inside the resulting div (overwriting previous message 'attempting to save') and swap out className for result. Allows for conditional styling.
			requestElement.innerText = `${result} in ${roundTripTime}ms`;
			requestElement.className = 'result';
			//appendResult is a socket creator. Fires a message named filesaveresult, payload is the innerText plus the id of the request element...
			appendResult(requestElement.innerText, requestElement.id, aTerminal.id);
			window.history.pushState({},null,`http://${window.location.host}/savedTrees/${aTerminal.id}.html${location.search}`)
			fireSubscribe();
			//sets documnent.head text tag inner text to current terminal id. 
			updateTitleText(aTerminal.id);
		})
	}
	//if the save command was triggered via socket message, just return the request div, with the matching id.
	return requestElement;

}

function collapseCodeMirrors(liveTree){
	let mirrors = Array.from(liveTree.getElementsByClassName('codemirrorContainer'));
	mirrors.forEach(aMirrorContainer =&gt; {
		let cm = aMirrorContainer.getElementsByClassName('CodeMirror')[0];
		cm.remove();
	})
}

function appendSaveTime(liveTree,updateTerminalId,elementToClone){
	//BOGUS! getElementById only works when you have a document, and an html element is NOT a document
	// let terminalToAppendTo = liveTree.getElementById(updateTerminalId)
	// I'll use querySelector instead
	let terminalToAppendTo = liveTree.querySelector(`#${updateTerminalId}`)
	let fileToSaveSize = formatBytes(liveTree.innerHTML.length,-1);
	//it screwed things up to try modifing the element that was being attached to the actualy dom. bad move in an async world. clone it instead.
	let elementToAppend = elementToClone.cloneNode();
	elementToAppend.innerText = `${fileToSaveSize} written successfully to ${updateTerminalId}.html at ${new Date()}`;
	terminalToAppendTo.appendChild(elementToAppend);
	initPrompt(terminalToAppendTo)
}

function updateTitleText(newName){
		let possibleCurrentTitle = document.getElementsByTagName('TITLE')[0];
		if(!possibleCurrentTitle){
			possibleCurrentTitle = document.head.appendChild(document.createElement('title'));
		}
		possibleCurrentTitle.innerText = newName;
}

function saveCodeMirrorContent(){
		let mirrors = Array.from(document.getElementsByClassName('codemirrorContainer'));
		mirrors.forEach(aMirrorContainer =&gt; {
			let cm = aMirrorContainer.cm;
			cm.save();
			let textArea = aMirrorContainer.getElementsByTagName('TEXTAREA')[0];
			textArea.innerHTML = textArea.value;
		})
}


function createResult(className, innerText){
  var placeHolder = document.createElement('div');
	placeHolder.className = className ? className : 'result'; //default className
	placeHolder.id = Date.now();
	placeHolder.innerHTML = innerText ? innerText : ' '; // default innerText
  return placeHolder;
}

function whoami(aLeaf){
//build a response placeholder, progress bar dealio
//create an id for that placeholder. Probably a span. 
//emit the request and pass the id of the placeholder
//return the placeholder. Later, when the response is
//received, the id will be returned as a part of the 
//payload so that the information can be stuffed back
//into the placeholder correspondant with that id.
	var placeHolder = createResult('query');
	socket.emit('identityRequest', {placeHolderId: placeHolder.id});	
	return placeHolder;
}

socket.on('identityResponse', function(socket){
	var roundTripTime = Date.now() - socket.placeHolderId; 
	var requestElement = document.getElementById(socket.placeHolderId);
  requestElement.className = 'result';
	requestElement.innerHTML = (socket.ipaddress === '1') ? 'localhost' : socket.ipaddress;	
});

function whatami(aLeaf){
	return createResult('result', aLeaf.id + ' is a ' + aLeaf.toString() + ' with classes "' + aLeaf.className + '"');
	//grab class name. id. just attributes of the terminal. 
}

function whereami(aLeaf){
	return createResult('result', aLeaf.id + " is " + aLeaf.style.left + " from the left and " + aLeaf.style.top + " from the top of its parent element, " + aLeaf.parentElement.tagName + ".");
	//just grab x y coordinates. Maybe find oneself in the dom. Which child?
}

function howami(aLeaf){
 // maybe each consturctor has a mthod, such that, the DIV from which the question is asked could simply call its own method, perhaps printing its identifying information. The constructor function, the file, the person who created it. Bare minimum, the div contains an attribute, a reference to its constructor, which exists in the global scope, so it can be printed by name. As for filename...
}

function whenami(){
	var placeHolder = createResult('query');
	socket.emit('timeRequest', {placeHolderId: placeHolder.id});	
	return placeHolder;
}

socket.on('timeResponse', function(socket){
	var roundTripTime = Date.now() - socket.placeHolderId; //currenttime in ms was used for id.
	var requestElement = document.getElementById(socket.placeHolderId);
  	requestElement.className = 'result';
	requestElement.innerHTML = 'Server time is: ' + socket.serverTime;	
	var localtimeResult = requestElement.cloneNode();
	var roundtripResult = requestElement.cloneNode();
	localtimeResult.innerHTML = 'Local time is:' + Date();
	roundtripResult.innerHTML = 'Round trip time to ' + window.location.host + ' was ' + roundTripTime + 'ms.';
	requestElement.parentNode.insertBefore(localtimeResult, requestElement);
	requestElement.parentNode.insertBefore(roundtripResult, localtimeResult);
	requestElement.parentNode.scrollTop = requestElement.parentNode.scrollHeight;
});

function runFile(event){
	//targetTerminal determines what the container element of a file is, for purposes of appending the result and socketizing the target to sync others
	//event.path returns an array of elements the event bubbled up through, from the event.target to the window. Filter it down to one element. 
	// This will work as long as you don't have a terminal within a terminal 
	let targetTerminal = event.path.filter(el =&gt; el.className &amp;&amp; el.className.includes('terminal'))[0];
	//the title attribute of the event target is the pathname of the file displayed.
	let targetPath = event.target.title;
	//this is for generating the equivelant command that could be typed. Maybe I should just generate that text as if it were typed and execute???
	let prompt = targetTerminal.getAttribute('protoPrompt');
  //Huh. open FILE is like create Codemirror FILETEXT. prints ls when re-executing list...
	if(event.target.className &amp;&amp; event.target.className.includes('directory')){
		targetTerminal.lastChild.innerText = `${prompt} ls ${targetPath}`
	} else if(event.target.className &amp;&amp; event.target.className.includes('text')){
		targetTerminal.lastChild.innerText = `${prompt} open ${targetPath}`
	} 

	//Oh yeah, it does these things whether you single clicked or double clicked, but then checks for double click before executing.
	if(event.type === 'dblclick'){
		if(event.target.className &amp;&amp; event.target.className.includes('directory')){
			//socketizing with custom command (which I belive is just bounced), and the socket object includes the id of the terminal, the name of a function, and a pathname.
			socket.emit('remoteRunFile', { terminal: targetTerminal.id, func: 'ls', path: targetPath});
			//Similar action, just different if you're opening or listing. runs ls - oh, from here ls is just a shortcut for the function name, not a property of the customCommands object.'
			let listResult = ls(targetTerminal, [targetPath]);
			targetTerminal.appendChild(listResult);
			initPrompt(targetTerminal);
		} else if(event.target.className &amp;&amp; event.target.className.includes('text')){
			socket.emit('remoteRunFile', { terminal: targetTerminal.id, func: 'open', path: targetPath});

			let fileOpenResult = open(targetTerminal, [targetPath]);
			targetTerminal.appendChild(fileOpenResult);
			initPrompt(targetTerminal);
		}
	}


}



function addDblClickListeners(directoryElement){
	let listOfFiles = Array.from(directoryElement.getElementsByClassName('fs'));
	listOfFiles.forEach(el =&gt; el.addEventListener('dblclick', runFile));
	listOfFiles.forEach(el =&gt; el.addEventListener('click', runFile));
}
</textarea></div><div tabindex="1" class="leaf codemirrorContainer" id="Codemirror4" style="left: 1266px; top: 186px; width: 700px; height: 400px; position: absolute; background: white;"><h3 class="entityHeader">Codemirror4 &gt; /public/js/constructors/Terminal.js<div class="editButton">R</div><div class="removeButton">X</div></h3><textarea style="display: none;">function Terminal(xPos, yPos){
  Leaf.call(this, xPos, yPos);
  this.element.setAttribute('history', 0); //0 is most recent, negative numbers go back in time
  this.element.id = "root" + nextIdNum('.terminal');
  this.element.className += ' terminal'; //addClass terminal to existing className
  this.element.setAttribute('protoPrompt', 'localhost/' + this.element.id + " &gt; ");
	//not sure if I can rely on the first child of the header to be the text Node, maybe there's a more generalizable way to get to the text node
  this.entityHeader.firstChild.textContent = this.element.id;
  
  var editButton = this.entityHeader.querySelector('.editButton');
  editButton.remove();

  let protoPrompt = this.element.getAttribute('protoPrompt');
  let prompt = document.createElement('p');
  prompt.className = 'prompt';
  prompt.innerHTML = this.element.getAttribute('protoPrompt');
  this.element.appendChild(prompt);
}

Terminal.prototype.render = function(){
  return this.element;
}

function updateTerminal(result, requestElementId, aTerminalId){
  //boolean guards are necessary because the socket.emit(fileSaveUpdate is invoked whether the command save was run or ctrl s was hit, and when ctrl s is hit, a new element is not appended to the terminal.)  
  let spanToUpdate = document.getElementById(requestElementId);
  //if the spantoupdate exists, set its innerText to the payload of the fileSaveResult socket emitter.
  spanToUpdate &amp;&amp; (spanToUpdate.innerText = result);

  window.history.pushState({},null,`http://${window.location.host}/savedTrees/${aTerminalId}.html${location.search}`)
  fireSubscribe();
  spanToUpdate &amp;&amp; (spanToUpdate.className = 'result');
}

function shiftHistory(increment){
  let history = Number(this.getAttribute('history'));
  let protoPrompt = this.getAttribute('protoPrompt');
  var listOfPrompts = this.getElementsByClassName('prompt');
  if(increment === -1 &amp;&amp; history &gt; 1){
    history += increment;
    this.lastChild.innerHTML = listOfPrompts[listOfPrompts.length - (1 + history)].innerHTML;
    this.setAttribute('history',history)
  } else if(increment === 1 &amp;&amp; history &lt; listOfPrompts.length - 1){
    history += increment;
    this.lastChild.innerHTML = listOfPrompts[listOfPrompts.length - (1 + history)].innerHTML;
    this.setAttribute('history',history)
  } else if(increment === -1 &amp;&amp; history == 1){
    this.lastChild.innerHTML = protoPrompt;
    history += increment;
    this.setAttribute('history',history)

  }
}


function handleKeystroke(aKeystroke, aKeyCode, aTarget, options){
    var terminal = document.getElementById(aTarget);
    if(aKeystroke == 'Backspace'){
      terminal.lastChild.innerHTML = terminal.lastChild.innerHTML.slice(0, -1)
    } else if( (aKeyCode &gt;= 48 &amp;&amp; aKeyCode &lt;= 90) || (aKeyCode &gt;= 186 &amp;&amp; aKeyCode &lt;= 222) || (aKeystroke == " ")) {
      terminal.lastChild.innerHTML += aKeystroke;
    } else if(aKeystroke == 'Enter'){
      handleInput(terminal, options)
    } else if(aKeystroke == 'ArrowUp'){
      shiftHistory.call(terminal, 1); //back in time, maxxing out at length of child nodes.
    } else if(aKeystroke == 'ArrowDown'){
      shiftHistory.call(terminal, -1); //forward in time, maxxing out at 0
    }
    terminal.scrollTop = terminal.scrollHeight;
}

// for some commands it is necessary to know if the keystroke was local or remote. isLocal carries this info.
function handleInput(aTerminal,options){
    aTerminal.history = 0;
    var query = aTerminal.lastChild.innerHTML.split('&gt;')[1];
    //Trim whitespace, split on space, check if that first result is in the list of keywords. If it is, return (or call) the property of that name. Else, run the whole phrase as a query
    var result;
		var potentialCommand = query.trim().split(' ')[0]; //even for empty strings or strings with no spaces, the result of trim().split() will be an array with at least one element. 
		if(customCommands[potentialCommand]){
      let potentialArguments = query.trim().split(' ').slice(1); // returns an empty array if no args, otherwise, arguments are passed as an array
      console.log(potentialArguments)                                       
      //This is kind of a mess. When I added a general exec command for whitelisted serverside CLI tools (git, mkdir, ffmpeg, touch), I decided I needed to know which command was run,
      //But so far all my other commands are set to expect arguments as an array. Since I need to know the requested command inside the general exec function inside customCommands.js,
      //I roll up the options passed to handleInput (right now, just if a command was executed locally or remotely) with an object contained potentialCommand, destructured es6 style.
    	
      result = customCommands[potentialCommand](aTerminal,potentialArguments,Object.assign({potentialCommand},options)); //calls the function, should return an Element
		} else {
      result = evaluate(aTerminal, query); 
		}

    aTerminal.appendChild(result);
    result.className += " result";

    initPrompt(aTerminal);
    
}

function initPrompt(aTerminal){
    var prompt = document.createElement('p');
    prompt.className = "prompt";
    prompt.innerHTML = aTerminal.getAttribute('protoPrompt');
    aTerminal.appendChild(prompt);
    aTerminal.scrollTop = aTerminal.scrollHeight;
}

function evaluate(aTerminal, aQuery){
		var result = createResult();
		result.className = 'result';
    try {
      var localEval = function(){return eval(aQuery)}; 
      result.innerHTML = localEval.call(aTerminal);
			return result;
    } catch(e) {
			console.log(e);
			result.innerHTML = e;
			return result;
    }
}

document.documentElement.addEventListener('keydown', function(event){
  //IF you're typing in a terminal, AND you're not holding down the CTRL key.
  if(document.activeElement.className.indexOf('terminal') !== -1 &amp;&amp; !event.ctrlKey){
    event.preventDefault(); //I don't remember why this is here.
    var terminal = document.activeElement;
	  socketize(event, terminal.id);
    handleKeystroke(event.key, event.keyCode, terminal.id, {isLocal: true});
  }
});

//Use to have the dblclick add terminal listener in here, moved it to utils.js. Will be refactored to create whatever is the default. 
// document.documentElement.addEventListener('dblclick', event =&gt; {
//   if(event.target.tagName === 'HTML' || event.target.tagName === 'BODY'){//only addTerminal if body or higher (document where there is no body) is clicked. Top of the path is Window -&gt; Document -
//     socketize(event);
//     addTerminal(event.clientX, event.clientY);
//   }
// });

// function addTerminal(posX, posY){
//   var aTerminal = new Terminal(posX, posY);
//   document.body.appendChild(aTerminal.element);
//   aTerminal.element.focus();
// }
</textarea></div></body>